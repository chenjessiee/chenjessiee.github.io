<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode刷题day15——回溯法end</title>
    <link href="/2024/11/29/LeetCode%E5%88%B7%E9%A2%98day15%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95end/"/>
    <url>/2024/11/29/LeetCode%E5%88%B7%E9%A2%98day15%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95end/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day15——回溯法-end"><a href="#LeetCode刷题day15——回溯法-end" class="headerlink" title="LeetCode刷题day15——回溯法(end)"></a>LeetCode刷题day15——回溯法(end)</h1><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[&quot;Q&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>刚开始看到这题是困难，我都不想做了。。。但是课堂上偏偏用的是N皇后讲回溯法，没事，我还能肝！下一道是解数独，也是困难，但是我对这个蛮感兴趣的，那就做一做，看看计算机是怎么思考的！肝！</p><p>这题是用横向循环遍历行内元素，递归深度遍历每一行。一层循环就行。一开始看到棋盘问题，就会觉得是二重循环，其实不是，因为每层只需要填一个数字而已。</p><p>蛮有意思的，这题！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    <span class="hljs-comment">//set&lt;vector&lt;string&gt;&gt; res1;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isval</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt; chessboard,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//这里并不用验证行，是因为每次行是递归的，在验证时，行上肯定只有一个Q</span><br>        <span class="hljs-comment">//col</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            <span class="hljs-keyword">if</span>(chessboard[i][c]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;;<br>        <span class="hljs-comment">//45度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r<span class="hljs-number">-1</span>,j=c<span class="hljs-number">+1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;n;i--,j++) &#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;;<br>        &#125;<br>        <span class="hljs-comment">//这样写有bug，因为棋盘大的时候，斜对角不止一个格子</span><br>        <span class="hljs-comment">// if(r-1&gt;=0&amp;&amp;c+1&lt;n&amp;&amp;chessboard[r-1][c+1]==&#x27;Q&#x27;) return false;</span><br>        <span class="hljs-comment">// if(r+1&lt;n&amp;&amp;c-1&gt;=0&amp;&amp;chessboard[r+1][c-1]==&#x27;Q&#x27;) return false;</span><br>        <span class="hljs-comment">//135</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r<span class="hljs-number">-1</span>,j=c<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>;i--,j--) &#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;;<br>        &#125;<br>        <span class="hljs-comment">//if(r-1&gt;=0&amp;&amp;c-1&gt;=0&amp;&amp;chessboard[r-1][c-1]==&#x27;Q&#x27;) return false;</span><br>        <span class="hljs-comment">// if(r+1&lt;n&amp;&amp;c+1&lt;n&amp;&amp;chessboard[r+1][c+1]==&#x27;Q&#x27;) return false;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;string&gt; &amp;chessboard,<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(r==n) &#123;<span class="hljs-comment">//注意这里的==，因为r from 0 to n-1</span><br>            res.<span class="hljs-built_in">push_back</span>(chessboard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>;col&lt;n;col++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isval</span>(chessboard,r,col,n)) &#123;<br>                chessboard[r][col]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">backtracking</span>(chessboard,n,r<span class="hljs-number">+1</span>);<br>                chessboard[r][col]=<span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//back</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>       <span class="hljs-comment">// vector&lt;string&gt; chessboard(n,(n,&quot;.&quot;));</span><br>       <span class="hljs-comment">//一直有很多重复结果，其实去重之后答案也并不正确，棋盘初始化的错误导致，输出了很多错误的结果</span><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br><br>        <span class="hljs-built_in">backtracking</span>(chessboard,n,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//以后最好从过程中找问题，而不是最后来处理重复的结果，本质不在这里</span><br>        <span class="hljs-comment">//res.assign(res1.begin(),res1.end());</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>],[<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><p>这是我做到的第一个需要在递归里面用两层循环的题，而且上来就写循环，也没有终止条件？！是的，总会酷酷退出的。本题有难度，写！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isval</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; board, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">char</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//row</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[r][i] == val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(board[i][c] ==val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> start_row=(r/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>;<span class="hljs-comment">//只用检查自己所在的九宫格即可，这样直接算出来挺好</span><br>        <span class="hljs-type">int</span> start_col=(c/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start_row; i &lt; start_row + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = start_col; j &lt; start_col + <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == val)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; board)</span> </span>&#123;<br>        <span class="hljs-comment">//此函数没有终止条件，总会终止的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这里忘记跳过了</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;=<span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;<span class="hljs-comment">//字符1-9竟然还可以这样，以前没用过这样的</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isval</span>(board,i,j,k)) &#123;<br>                        board[i][j] = k;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//九个数字都不行，肯定不行</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day14——回溯法</title>
    <link href="/2024/11/27/LeetCode%E5%88%B7%E9%A2%98day14%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2024/11/27/LeetCode%E5%88%B7%E9%A2%98day14%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day14——回溯法"><a href="#LeetCode刷题day14——回溯法" class="headerlink" title="LeetCode刷题day14——回溯法"></a>LeetCode刷题day14——回溯法</h1><p>当然，还是不想写题解，懒猪儿~有啥要注意的写注释里了，嘿嘿。下了好几天雨，今天出太阳了，心情美丽。今天是2024年11月27日。</p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">// vector&lt;int&gt; visit;</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt;&amp; visit)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i] ==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 这样写是横向纵向是完全树，但是自身不能选，于是想到树的遍历方式，用visit数组来记录，但是刚才出现一个问题，就是我得把visit传参才不会报错</span><br><span class="hljs-comment">/*在原始代码中，visit数组是在Solution类的成员变量，这意味着它是类的静态成员，而不是每个对象的独立成员。这会导致几个问题：</span><br><span class="hljs-comment">共享状态：所有Solution对象共享同一个visit数组。这意味着如果你创建了多个Solution对象并调用它们的permute方法，它们都会修改同一个visit数组，这显然不是你想要的行为。</span><br><span class="hljs-comment">未定义行为：由于backtracking函数试图访问一个它不应该访问的成员变量，这可能导致未定义行为，比如你遇到的运行时错误。*/</span><br>                <br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            visit[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums, i, visit);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            visit[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 初始化visit数组</span><br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>, visit);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="47-全排列Ⅱ"><a href="#47-全排列Ⅱ" class="headerlink" title="47. 全排列Ⅱ"></a>47. 全排列Ⅱ</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visit)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i]==<span class="hljs-literal">true</span>)<br>            <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;visit[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>            <span class="hljs-comment">//if(i&gt;0&amp;&amp;visit[i-1]=true&amp;&amp;nums[i]==nums[i-1] true or false 都可以</span><br>            <span class="hljs-comment">//if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) 报错</span><br>            <span class="hljs-comment">//一定要加上 used[i - 1] == false或者used[i - 1] == true，因为 used[i - 1] 要一直是 true 或者一直是false 才可以，而不是 一会是true 一会又是false。 所以这个条件要写上。</span><br>            <span class="hljs-comment">//分析如下：横向分枝时，所有的都是没使用过的，比如【1，2，3】，分成三个枝1，2，3，开启新的枝，全部都是没使用的</span><br>            <span class="hljs-comment">// visit[i - 1] == true，说明同一树枝nums[i - 1]使用过</span><br>            <span class="hljs-comment">// visit[i - 1] == false，说明同一树层nums[i - 1]使用过</span><br>                <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            visit[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums,visit);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            visit[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums,visit);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day13——回溯法</title>
    <link href="/2024/11/26/LeetCode%E5%88%B7%E9%A2%98day13%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2024/11/26/LeetCode%E5%88%B7%E9%A2%98day13%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day13——回溯法"><a href="#LeetCode刷题day13——回溯法" class="headerlink" title="LeetCode刷题day13——回溯法"></a>LeetCode刷题day13——回溯法</h1><h2 id="90-子集"><a href="#90-子集" class="headerlink" title="90. 子集"></a>90. 子集</h2><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 </p><p>子集</p><p>（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>注意的地方写在注释里，因为想要简单记录，所以不做详细的分析了，这题比较简单。感觉最近时间过得好快，每天打题需要快速解决了。但是也不能单纯求快，还得搞懂再溜。</p><p>最近看到一些话挺有感触的：怎么学习？一有空就学！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&gt;=path.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-comment">//注意别拿start来搞，应该拿结果和原数组个数比</span><br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==path.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>           <span class="hljs-keyword">if</span>( i&gt;start&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>] ) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// if(nums[i]==nums[i-1] &amp;&amp; i&gt;start)这样写不行，超出访问界限，不应先判断数组，应先判断下标</span><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i<span class="hljs-number">+1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//先排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="491-非递减子序列"><a href="#491-非递减子序列" class="headerlink" title="491. 非递减子序列"></a>491. 非递减子序列</h2><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,6,7,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,6]</span>,<span class="hljs-comment">[4,6,7]</span>,<span class="hljs-comment">[4,6,7,7]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[4,7,7]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[6,7,7]</span>,<span class="hljs-comment">[7,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[4,4]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 15</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>这题比上题难一些，不能重新排序去做，因为要求元素的相对顺序。</p><ul><li><p>递增子序列中至少有两个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>) <br>res.<span class="hljs-built_in">push_back</span>(path);<br><span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==path.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li><li><p>怎么处理递增？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">path.<span class="hljs-built_in">back</span>()&lt;=nums[i]<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res1;<span class="hljs-comment">//去重</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>) &#123;<br>            res<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(path);<br>           <br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==path.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">empty</span>() || path.<span class="hljs-built_in">back</span>()&lt;=nums[i]) &#123;<span class="hljs-comment">//这个判断就是非递减判断</span><br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums,i<span class="hljs-number">+1</span>);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>);<br>        res.<span class="hljs-built_in">assign</span>(res<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(),res<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day12——回溯法</title>
    <link href="/2024/11/25/LeetCode%E5%88%B7%E9%A2%98day12%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2024/11/25/LeetCode%E5%88%B7%E9%A2%98day12%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day12——回溯法"><a href="#LeetCode刷题day12——回溯法" class="headerlink" title="LeetCode刷题day12——回溯法"></a>LeetCode刷题day12——回溯法</h1><p>头疼，想不明白前真的想不明白，想明白了是真的明白了，我要吐了。。。。</p><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;25525511135&quot;</span><br>输出：[<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0000&quot;</span><br>输出：[<span class="hljs-string">&quot;0.0.0.0&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;101023&quot;</span><br>输出：[<span class="hljs-string">&quot;1.0.10.23&quot;</span>,<span class="hljs-string">&quot;1.0.102.3&quot;</span>,<span class="hljs-string">&quot;10.1.0.23&quot;</span>,<span class="hljs-string">&quot;10.10.2.3&quot;</span>,<span class="hljs-string">&quot;101.0.2.3&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>思路写在注释里，麻了麻了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    string combine;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> sumdot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span> &amp;&amp; sumdot == <span class="hljs-number">4</span>) &#123;<span class="hljs-comment">//注意这里的&amp;&amp;，和4</span><br>            <span class="hljs-type">int</span> len=combine.<span class="hljs-built_in">length</span>();<br>            <span class="hljs-keyword">if</span>(combine[len<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                combine.<span class="hljs-built_in">pop_back</span>();<br>            res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>||sumdot==<span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">length</span>()&amp;&amp;i&lt;=<span class="hljs-number">3</span>; i++) &#123;<span class="hljs-comment">//i &lt;= s.length()&amp;&amp;i&lt;=3注意这个条件，=！！！！为此卡了很久，还有&lt;=3这个条件，分割的字符，最多是三位数</span><br>            string tmp = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i);<br>            <span class="hljs-keyword">if</span> (tmp[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; tmp.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(tmp);<br>            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            string tmp2 = combine;<br>            combine.<span class="hljs-built_in">append</span>(tmp + <span class="hljs-string">&#x27;.&#x27;</span>);<br>            <span class="hljs-built_in">backtracking</span>(s.<span class="hljs-built_in">substr</span>(i), sumdot<span class="hljs-number">+1</span>);<span class="hljs-comment">//这样传参，1. 直接切割字符，要求是参数不能引用。2. sumdot其实是段数，分成四段，+1传参这样就不用复原</span><br>            combine = tmp2;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() &lt; <span class="hljs-number">4</span> || s.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">12</span>)  <span class="hljs-comment">// 如果字符串长度不在 4 到 12 之间，直接返回空</span><br>            <span class="hljs-keyword">return</span> res;<br>       <br>        <span class="hljs-type">int</span> sumdot = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">backtracking</span>(s, sumdot);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的</p><p>子集</p><p>（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><p>这不是很简单马？马失前蹄，我真的。。。。。</p><p>被gpt修复了，但是有的我还没时间改：</p><ul><li>你的代码问题在于以下几个方面：</li></ul><ol><li><strong>重复子集问题：</strong><ul><li>在 <code>backtracking(nums, start+1);</code> 中，你没有正确递增 <code>start</code> 的值，而是始终传入 <code>start+1</code>。这导致在递归中同一个元素被重复选择，出现了重复的子集。（实在致命的问题，想了好久才想通）</li></ul></li><li><strong>逻辑问题：</strong><ul><li><code>uniq</code> 用于去重，但是直接用 <code>set</code> 存储 <code>path</code> 来去重不是最佳方法，<strong>问题的本质是如何避免重复，而不是依赖于结果后期处理</strong>。（说得好）</li></ul></li><li><strong>多余逻辑：</strong><ul><li>在 <code>subsets</code> 函数中你手动添加了空集，但实际上在回溯过程中，空集会自然地包含，不需要手动插入。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; uniq;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums,<span class="hljs-type">int</span> start)</span> </span>&#123;<br>       <span class="hljs-comment">// cout&lt;&lt;&quot;backtracking&quot;&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()&lt;=nums.<span class="hljs-built_in">size</span>()) &#123;<br>            uniq.<span class="hljs-built_in">insert</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums,i<span class="hljs-number">+1</span>);<span class="hljs-comment">//backtracking(nums,start+1);这是错的，在这里卡住了，正确的写法，理解为：在深度上来看，是不会出现重复选择的，比如选1，剩下的以1为父节点的子树，是不会再选到1</span><br>            <span class="hljs-comment">//错误的地方在于：之前i=1已经执行过。此时i=2，但是start=0,意思是，在选择第一层树时，第二个孩子应该是2往后选，但是因为还是之前的start所以，这个时候，第二层还是从1开始选的，造成重复</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>        uniq.<span class="hljs-built_in">insert</span>(tmp);<br>        res.<span class="hljs-built_in">assign</span>(uniq.<span class="hljs-built_in">begin</span>(), uniq.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day11——回溯法</title>
    <link href="/2024/11/23/LeetCode%E5%88%B7%E9%A2%98day11%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2024/11/23/LeetCode%E5%88%B7%E9%A2%98day11%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day11——回溯法"><a href="#LeetCode刷题day11——回溯法" class="headerlink" title="LeetCode刷题day11——回溯法"></a>LeetCode刷题day11——回溯法</h1><h2 id="40-组合总和Ⅱ"><a href="#40-组合总和Ⅱ" class="headerlink" title="40.组合总和Ⅱ"></a>40.组合总和Ⅱ</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>开心的写完，发现172&#x2F;176,最后测试：[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]，target &#x3D;30.内存超过限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> &amp;target,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span>&amp; sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;target)<br>        <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=candidates[i];<br>            combine.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates,target,i<span class="hljs-number">+1</span>,sum);<br>            sum-=candidates[i];<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span>&#123;<span class="hljs-comment">//去重</span><br>        set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; v:res)&#123;<br>            <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>            a.<span class="hljs-built_in">insert</span>(v);<br>        &#125;<br>        res.<span class="hljs-built_in">assign</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=candidates[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&lt;target)<br>            <span class="hljs-keyword">return</span> res;<br>        sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">backtracking</span>(candidates,target,<span class="hljs-number">0</span>,sum);<br>        <span class="hljs-built_in">remove</span>(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>发现是没剪枝优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> &amp;target,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span>&amp; sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;target)<br>        <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>])<span class="hljs-comment">//剪枝，如果不写这个，会内存超限。原因是该搜索分枝重复，直接跳过</span><br>            <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(target&lt;candidates[i])<span class="hljs-comment">//剪枝，候选数字比目标更大，并且已经排好序了，后续只会越来越大。</span><br>                <span class="hljs-keyword">break</span>;<br>            sum+=candidates[i];<br>            combine.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <br>            <span class="hljs-built_in">backtracking</span>(candidates,target,i<span class="hljs-number">+1</span>,sum);<br>            sum-=candidates[i];<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span>&#123;<span class="hljs-comment">//优化之后，不用再这样去重</span><br>        set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; v:res)&#123;<br>            <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>            a.<span class="hljs-built_in">insert</span>(v);<br>        &#125;<br>        res.<span class="hljs-built_in">assign</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=candidates[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&lt;target)<br>            <span class="hljs-keyword">return</span> res;<br>        sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates,target,<span class="hljs-number">0</span>,sum);<br>     <span class="hljs-comment">//  remove(res);</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 </p><p><strong>回文串</strong></p><p> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><p>这道题，要解决两个问题？</p><ul><li>怎么判断是不是回文串——双指针法即可</li><li>每一个答案都被穷举，说明要用回溯法，怎么用？</li></ul><p>要清楚，正在处理<code>pre=s.substr(0,i);</code>的和未处理的<code>s.substr(i)</code>，看清楚，想清楚再用回溯法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;string&gt; combine;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHui</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; pre)</span> </span>&#123;<span class="hljs-comment">//双指针法</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=pre.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j) &#123;<br>            <span class="hljs-keyword">if</span>(pre[i]!=pre[j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            string pre=s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i);<span class="hljs-comment">//正要处理的</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHui</span>(pre)) &#123;<br>                combine.<span class="hljs-built_in">push_back</span>(pre);<br>                <span class="hljs-built_in">backtracking</span>(s.<span class="hljs-built_in">substr</span>(i));<span class="hljs-comment">//递归去看未处理的</span><br>                combine.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">length</span>()==<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//优化</span><br>            combine.<span class="hljs-built_in">emplace_back</span>(s);<br>            res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">backtracking</span>(s);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day10——回溯法</title>
    <link href="/2024/11/22/LeetCode%E5%88%B7%E9%A2%98day10%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2024/11/22/LeetCode%E5%88%B7%E9%A2%98day10%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day10——回溯法"><a href="#LeetCode刷题day10——回溯法" class="headerlink" title="LeetCode刷题day10——回溯法"></a>LeetCode刷题day10——回溯法</h1><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：digits <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;2&quot;</span><br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题是多个集合求组合。最近都没有认真写思路分析，总之首先看到这个题的时候，脑子乱乱的。怎么从数字对应到字母？原来只要做一个映射就好？怎么把字符串变成数字？stoi函数倒是可以，直接变了未免太麻烦，因为这样不好单位取出数字。后面发现，直接减法最快。最关键的问题，就是<strong>这题的回溯法，横向是怎样生长，纵向又是怎样生长？</strong></p><ul><li>横向是每个数字对应集合的生长，也就是说，for循环的上界，是每个集合自身的长度</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png" alt="17. 电话号码的字母组合"></p><ul><li>纵向是按输入的digi的长度纵向生长，有几个数字，树就有几层</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n=dig[index]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//转数字</span><br>string letter=s[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;letter.<span class="hljs-built_in">length</span>();i++) &#123;<span class="hljs-comment">//按照每个集合的字母长度横向生长</span><br>conbine.<span class="hljs-built_in">push_back</span>(letter[i]);<br>    <span class="hljs-built_in">backtracking</span>(len,dig,conbine,res,index<span class="hljs-number">+1</span>);<span class="hljs-comment">//按照输入的数字，深度生长</span><br>    conbine.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的循环上界，递归深度，跟前面做的题不一样了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string s[<span class="hljs-number">10</span>]=&#123;<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-string">&quot;mno&quot;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>,<span class="hljs-string">&quot;tuv&quot;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> len,string dig,string &amp; conbine,vector&lt;string&gt; &amp; res,<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==len) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(conbine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n=dig[index]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//转数字</span><br>        string letter=s[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;letter.<span class="hljs-built_in">length</span>();i++) &#123;<span class="hljs-comment">//按照每个集合的字母长度横向生长</span><br>            conbine.<span class="hljs-built_in">push_back</span>(letter[i]);<br>            <span class="hljs-built_in">backtracking</span>(len,dig,conbine,res,index<span class="hljs-number">+1</span>);<span class="hljs-comment">//按照输入的数字，深度生长</span><br>            conbine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        string conbine;<br>        <span class="hljs-type">int</span> len=digits.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">backtracking</span>(len,digits,conbine,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[2,2,2,2]</span>,<span class="hljs-comment">[2,3,3]</span>,<span class="hljs-comment">[3,5]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2]</span>, target = 1<br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>之前好像做过一个这种题目，不过是不允许重复数字，这个允许重复，而且允许自己重复许多次！？淦，总是想考倒我！首先写出基本的回溯模板，然后想想怎么做。比如【1，2，3，4】</p><ul><li>回溯宽度，也就是横向，选1，2，3，4</li><li>回溯深度，也就是纵向，还是要选1，2，3，4</li></ul><p>好像就解决了是吧，好像真是！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; candidates, <span class="hljs-type">int</span> target,<span class="hljs-type">int</span> &amp;sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sum&gt;target) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum==target) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;candidates.<span class="hljs-built_in">size</span>();i++) &#123;<br>            sum+=candidates[i];<br>            combine.<span class="hljs-built_in">emplace_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates,target,sum);<br>            sum-=combine.<span class="hljs-built_in">back</span>();<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> min = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidates[i] &lt; min) &#123;<br>                min=candidates[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min&gt;target) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">backtracking</span>(candidates,target,sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>报错了，输出结果是这样：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">我的输出<span class="hljs-comment">[2,2,3]</span>,<span class="hljs-comment">[2,3,2]</span>,<span class="hljs-comment">[3,2,2]</span>,<span class="hljs-comment">[7]</span><br><br>答案是    <span class="hljs-comment">[<span class="hljs-comment">[2,2,3]</span>,<span class="hljs-comment">[7]</span>]</span><br></code></pre></td></tr></table></figure><p>然后就是自然想到要去重，怎么去呢？set天然可以去重。首先我们需要把res的子数组排序，排序后的 <code>[2, 2, 3]</code> 和 <code>[2, 3, 2]</code> 都会变成 <code>[2, 2, 3]</code>，再把它们加入到set中，嘿嘿，大功告成！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>  <br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>        set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; unique;<br>         <span class="hljs-comment">// 对每个子数组排序并插入到 set 中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v:res) &#123;<br>            <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>            unique.<span class="hljs-built_in">insert</span>(v);<br>        &#125;<br>         <span class="hljs-comment">// 将去重后的结果存回 res</span><br>        res.<span class="hljs-built_in">assign</span>(unique.<span class="hljs-built_in">begin</span>(), unique.<span class="hljs-built_in">end</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; candidates, <span class="hljs-type">int</span> target,<span class="hljs-type">int</span> &amp;sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sum&gt;target) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum==target) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;candidates.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//横向宽度是所有，纵向每个还可以选所有</span><br>            sum+=candidates[i];<br>            combine.<span class="hljs-built_in">emplace_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates,target,sum);<br>            sum-=combine.<span class="hljs-built_in">back</span>();<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> min = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidates[i] &lt; min) &#123;<br>                min=candidates[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min&gt;target) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">backtracking</span>(candidates,target,sum);<br>        <span class="hljs-built_in">removeDuplicates</span>(res);<span class="hljs-comment">//新增去重</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day9——回溯法</title>
    <link href="/2024/11/21/LeetCode%E5%88%B7%E9%A2%98day9%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2024/11/21/LeetCode%E5%88%B7%E9%A2%98day9%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day9——回溯法"><a href="#LeetCode刷题day9——回溯法" class="headerlink" title="LeetCode刷题day9——回溯法"></a>LeetCode刷题day9——回溯法</h1><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt; &amp; combine, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(combine.<span class="hljs-built_in">size</span>() == k) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= n; i++) &#123;<span class="hljs-comment">//树的宽度</span><br>            combine.<span class="hljs-built_in">emplace_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(i + <span class="hljs-number">1</span>, n, k, combine, res);<span class="hljs-comment">//树的深度，往下钻</span><br>            combine.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯</span><br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>        <span class="hljs-built_in">backtracking</span>(<span class="hljs-number">1</span>,n,k,combine,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>剪枝优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//剪枝</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">例如：n = 6 ，k = 4。</span><br><span class="hljs-comment">path.size() == 1 的时候，接下来要选择 3 个数，搜索起点最大是 4，最后一个被选的组合是 [4, 5, 6]；</span><br><span class="hljs-comment">path.size() == 2 的时候，接下来要选择 2 个数，搜索起点最大是 5，最后一个被选的组合是 [5, 6]；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">可以归纳出：</span><br><span class="hljs-comment">搜索起点的上界 + 接下来要选择的元素个数 - 1 = n</span><br><span class="hljs-comment">其中，接下来要选择的元素个数 = k - path.size()，整理得到：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">搜索起点的上界 = n - (k - path.size()) + 1</span><br><span class="hljs-comment">所以，我们的剪枝过程就是：把 i &lt;= n 改成 i &lt;= n - (k - path.size()) + 1 ：</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt; &amp; combine, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(combine.<span class="hljs-built_in">size</span>() == k) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= n-(k-combine.<span class="hljs-built_in">size</span>())<span class="hljs-number">+1</span>; i++) &#123;<span class="hljs-comment">//剪枝</span><br>            combine.<span class="hljs-built_in">emplace_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(i + <span class="hljs-number">1</span>, n, k, combine, res);<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>        <span class="hljs-built_in">backtracking</span>(<span class="hljs-number">1</span>,n,k,combine,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="216-组合总和Ⅲ"><a href="#216-组合总和Ⅲ" class="headerlink" title="216.组合总和Ⅲ"></a>216.组合总和Ⅲ</h2><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出: <span class="hljs-string">[[1,2,4]]</span><br>解释:<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">4</span> = <span class="hljs-number">7</span><br>没有其他符合的组合了。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 6 </span>= 9<br>1 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>= 9<br>2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>= 9<br>没有其他符合的组合了。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: k = 4, n = 1</span><br><span class="hljs-section">输出: []</span><br><span class="hljs-section">解释: 不存在有效的组合。</span><br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt; &amp; combine, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; res,<span class="hljs-type">int</span> &amp;sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (combine.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span>(sum==n)<br>                res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=start; i&lt;=<span class="hljs-number">9</span>; i++) &#123;<br>            combine.<span class="hljs-built_in">emplace_back</span>(i);<br>            sum+=i;<br>            <span class="hljs-built_in">backtracking</span>(i<span class="hljs-number">+1</span>,k,n,combine,res,sum);<br>            sum-=combine.<span class="hljs-built_in">back</span>();<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>        <span class="hljs-type">int</span> min=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=k; i++) &#123;<br>            min+=i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min&gt;n)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">backtracking</span>(<span class="hljs-number">1</span>,k,n,combine,res,sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>剪枝优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt; &amp; combine, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; res,<span class="hljs-type">int</span> &amp;sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sum&gt;n)<span class="hljs-comment">//剪枝1</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(combine.<span class="hljs-built_in">size</span>()+(<span class="hljs-number">9</span>-start<span class="hljs-number">+1</span>)&lt;k)<span class="hljs-comment">//剪枝2.剩余数字不够</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (combine.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span>(sum==n)<br>                res.<span class="hljs-built_in">emplace_back</span>(combine);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=start; i&lt;=<span class="hljs-number">9</span>-(k-combine.<span class="hljs-built_in">size</span>())<span class="hljs-number">+1</span>; i++) &#123;<span class="hljs-comment">//剪枝3.剩余数字不够</span><br>            combine.<span class="hljs-built_in">emplace_back</span>(i);<br>            sum+=i;<br>            <span class="hljs-built_in">backtracking</span>(i<span class="hljs-number">+1</span>,k,n,combine,res,sum);<br>            sum-=combine.<span class="hljs-built_in">back</span>();<br>            combine.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; combine;<br>        <span class="hljs-comment">/*int min=0;</span><br><span class="hljs-comment">        for(int i=1; i&lt;=k; i++) &#123;</span><br><span class="hljs-comment">            min+=i;</span><br><span class="hljs-comment">        &#125;*/</span><br>        <span class="hljs-type">int</span> min = k * (k + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 1 到 k 的和公式</span><br>        <span class="hljs-keyword">if</span>(min&gt;n)<br>            <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">backtracking</span>(<span class="hljs-number">1</span>,k,n,combine,res,sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day8</title>
    <link href="/2024/11/20/LeetCode%E5%88%B7%E9%A2%98day8/"/>
    <url>/2024/11/20/LeetCode%E5%88%B7%E9%A2%98day8/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day8"><a href="#LeetCode刷题day8" class="headerlink" title="LeetCode刷题day8"></a>LeetCode刷题day8</h1><p>今天的题目，蛮力法都能做，但是想要优化，还是挺有意思的，数学上优化太神奇了！至此，链表复习结束！</p><h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++">蛮力法<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* a=headA;<br>        <span class="hljs-keyword">while</span>(a!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">//int x=a-&gt;val;</span><br>            ListNode* b=headB;<br>            <span class="hljs-keyword">while</span>(b!=<span class="hljs-literal">NULL</span>)&#123;<br>              <span class="hljs-comment">//  int y=b-&gt;val;</span><br>                <span class="hljs-keyword">if</span>(a==b)&#123;<span class="hljs-comment">//单纯比较值不可行，直接比较指针更好</span><br>                    <span class="hljs-keyword">return</span> b;<br>                &#125;<br>                b=b-&gt;next;<br>            &#125;<br>            a=a-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">双指针法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode* headA, ListNode* headB)</span> </span>&#123;<br>        ListNode* a = headA;<br>        ListNode* b = headB;<br>        <span class="hljs-keyword">while</span> (a != b) &#123;<span class="hljs-comment">//双指针法，如果相交，经过一样的步数，总会有一次同时到达相交节点；如果不相交，每个指针都遍历两个链表一次时，会同时到达末尾NULL，不会死循环</span><br>            a = a != <span class="hljs-literal">NULL</span> ? a-&gt;next : headB;<br>            b = b != <span class="hljs-literal">NULL</span> ? b-&gt;next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++">蛮力法<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* start = head;<br>        ListNode* p;<br>        <span class="hljs-keyword">while</span> (start != <span class="hljs-literal">NULL</span>) &#123;<br>            p = start-&gt;next;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">if</span> (p == start)<br>                    <span class="hljs-keyword">return</span> p;<br>                sum++;<br>                <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">10000</span>)<span class="hljs-comment">//蛮力法，真无语了哈哈。</span><br>                <span class="hljs-keyword">break</span>;<br>                p = p-&gt;next;<br>            &#125;<br>            start = start-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先，我看了官方解析，不太懂。</p><p>然后找到了一个解析，看明白了：</p><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day8/image-20241120152550407.png"></p><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day8/image-20241120152619702.png"></p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/2832831/jian-ji-qing-xi-yan-jin-de-tu-shi-tui-da-nak2/">https://leetcode.cn/problems/linked-list-cycle-ii/solutions/2832831/jian-ji-qing-xi-yan-jin-de-tu-shi-tui-da-nak2/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br><br>        <span class="hljs-comment">// 此处如果用 while (fast != slow)，则在一开始时就违背了条件</span><br>        <span class="hljs-comment">// 也可用 do while, 但以下代码更符合 repeat until (重复直到) 的思考习惯</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 指向空节点，说明无环。</span><br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>            <span class="hljs-comment">// fast 和 slow 异速前进</span><br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br><br>            <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// fast 和 slow 相遇</span><br>        &#125;<br><br>        <span class="hljs-comment">// ptr 和 slow 同速前进，直至相遇在入口</span><br>        ListNode* ptr = head;<br>        <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>            ptr = ptr-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ptr; <span class="hljs-comment">// 返回入口节点</span><br>    &#125;<br>&#125;;<br><br>作者：Shawxing精讲算法<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/linked-list-cycle-ii/solutions/2832831/jian-ji-qing-xi-yan-jin-de-tu-shi-tui-da-nak2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day7</title>
    <link href="/2024/11/20/LeetCode%E5%88%B7%E9%A2%98day7/"/>
    <url>/2024/11/20/LeetCode%E5%88%B7%E9%A2%98day7/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day7"><a href="#LeetCode刷题day7" class="headerlink" title="LeetCode刷题day7"></a>LeetCode刷题day7</h1><h2 id="19-删除链表的倒数第-N个结点"><a href="#19-删除链表的倒数第-N个结点" class="headerlink" title="19. 删除链表的倒数第 N个结点"></a>19. 删除链表的倒数第 N个结点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* p = dummy-&gt;next;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>            dummy-&gt;val++;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; dummy-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (n &gt; dummy-&gt;val || n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> dummy-&gt;next;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-type">int</span> index = dummy-&gt;val - n;<br>        p = dummy;<span class="hljs-comment">//第0个节点，</span><br>        <span class="hljs-keyword">while</span> (index--) &#123;<span class="hljs-comment">//如果index=3,往后跑三次就是：第一，第二，第三；就能找到第三个节点</span><br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; p-&gt;val &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span> || p-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 如果 p 无法安全访问或没有后继节点，则直接返回</span><br>            <span class="hljs-keyword">return</span> dummy-&gt;next;<br>        &#125;<br><br>        ListNode* temp = p-&gt;next;<br>        p-&gt;next = temp-&gt;next;<br><br>        <span class="hljs-keyword">delete</span> temp;<br>        dummy-&gt;val--;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>         ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>         dummy-&gt;next = head;<span class="hljs-comment">//dont forget</span><br>        ListNode* cur = head, *prev = dummy;<br>        <span class="hljs-keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;<br>            prev-&gt;next = cur-&gt;next;<br>            cur-&gt;next = prev-&gt;next-&gt;next;<br>            prev-&gt;next-&gt;next=cur;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next) &#123;<br>                prev=cur;<span class="hljs-comment">//我交换的是cur和cur-&gt;next，所以注意更新pre就是cur</span><br>                cur=cur-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<span class="hljs-comment">//注意这里，头节点已经被改变了，不能直接返回head</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day6</title>
    <link href="/2024/11/18/LeetCode%E5%88%B7%E9%A2%98day6/"/>
    <url>/2024/11/18/LeetCode%E5%88%B7%E9%A2%98day6/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day6"><a href="#LeetCode刷题day6" class="headerlink" title="LeetCode刷题day6"></a>LeetCode刷题day6</h1><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,6,3,4,5,6]</span>, val = <span class="hljs-number">6</span><br>输出：<span class="hljs-string">[1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>, val = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[7,7,7,7]</span>, val = 7<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//考虑了头节点删除和链表结构更新的问题，增加一个哑节点</span><br>       ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* p=dummy;<br>        ListNode* q=head;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;val==val) &#123;<br>                q-&gt;next=p-&gt;next;<br>                <span class="hljs-keyword">delete</span> p;<br>                p=q-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                q=p;<br>                p=p-&gt;next;<br>            &#125;<br>        &#125;<br>        head=dummy-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummy;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h2><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入<br>[<span class="hljs-string">&quot;MyLinkedList&quot;</span>, <span class="hljs-string">&quot;addAtHead&quot;</span>, <span class="hljs-string">&quot;addAtTail&quot;</span>, <span class="hljs-string">&quot;addAtIndex&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;deleteAtIndex&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>]<br><br>解释<br>MyLinkedList myLinkedList = <span class="hljs-keyword">new</span> MyLinkedList();<br>myLinkedList.addAtHead(<span class="hljs-number">1</span>);<br>myLinkedList.addAtTail(<span class="hljs-number">3</span>);<br>myLinkedList.addAtIndex(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 链表变为 1-&gt;2-&gt;3</span><br>myLinkedList.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);              <span class="hljs-comment">// 返回 2</span><br>myLinkedList.deleteAtIndex(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 现在，链表变为 1-&gt;3</span><br>myLinkedList.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);              <span class="hljs-comment">// 返回 3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *next;<br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, Node *next) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node *dummy;<span class="hljs-comment">//单链表+虚节点，便于操作链表，如何找到index结点？注意</span><br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<span class="hljs-comment">//index from：0</span><br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>||(index&gt;dummy-&gt;val<span class="hljs-number">-1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        Node* p=dummy-&gt;next;<span class="hljs-comment">//找到index</span><br>        <span class="hljs-keyword">while</span>(index--) &#123;<br>            p=p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        Node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, <span class="hljs-literal">NULL</span>);<br>        p-&gt;next = dummy-&gt;next;<br>        dummy-&gt;next = p;<br>        dummy-&gt;val++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        Node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, <span class="hljs-literal">NULL</span>);<br>        Node *q = dummy;<br>        <span class="hljs-keyword">while</span>(q-&gt;next!=<span class="hljs-literal">NULL</span>) &#123;<br>            q=q-&gt;next;<br>        &#125;<br>        q-&gt;next=p;<br>        dummy-&gt;val++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(index&gt;dummy-&gt;val)<br>           <span class="hljs-keyword">return</span>;<br>           <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>)<br>           index=<span class="hljs-number">0</span>;<br>        Node *p=dummy;<span class="hljs-comment">//找到index-1</span><br>        Node *q=dummy-&gt;next;<br>        <span class="hljs-keyword">while</span>(index--) &#123;<br>            p=p-&gt;next;<br>        &#125;<br>        Node *r=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, <span class="hljs-literal">NULL</span>);<br>        r-&gt;next=p-&gt;next;<br>        p-&gt;next=r;<br><br>        dummy-&gt;val++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>||index&gt;=dummy-&gt;val)<br>           <span class="hljs-keyword">return</span>;<br>        Node *p=dummy;<br>       <br>        <span class="hljs-keyword">while</span>(index--) &#123;<br>            p=p-&gt;next;<br>        &#125;<br>         Node *q=p-&gt;next;<br>        p-&gt;next=q-&gt;next;<br>        <span class="hljs-keyword">delete</span> q;<br>        p=<span class="hljs-literal">NULL</span>;<br>        dummy-&gt;val--;<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(index);</span><br><span class="hljs-comment"> * obj-&gt;addAtHead(val);</span><br><span class="hljs-comment"> * obj-&gt;addAtTail(val);</span><br><span class="hljs-comment"> * obj-&gt;addAtIndex(index,val);</span><br><span class="hljs-comment"> * obj-&gt;deleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 不要头指针，反而会更简单，不涉及最后dummy要变空的问题</span><br>        <span class="hljs-comment">// 原地反转，不应该重开一些空间，会浪费；直接把所有指针方向调转。</span><br>        ListNode* prev = <span class="hljs-literal">NULL</span>;<br>        ListNode* cur = head;<br>        ListNode* tmp;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            tmp = cur-&gt;next;<br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-comment">// if (head != NULL)</span><br>        <span class="hljs-comment">//  head-&gt;next = NULL;</span><br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是使用哑节点，也就是带头结点的单链表实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>       <span class="hljs-keyword">return</span> head;<br>       ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>       dummy-&gt;next = head;<br>       ListNode* prev = dummy;<br>       ListNode* cur = dummy-&gt;next;<br>       <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>           ListNode* tmp = cur-&gt;next;<br>           cur-&gt;next = prev;<br>           prev = cur;<br>           cur = tmp;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">NULL</span>)<br>           head-&gt;next = <span class="hljs-literal">NULL</span>;<br>       <span class="hljs-keyword">return</span> prev;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day5</title>
    <link href="/2024/11/16/LeetCode%E5%88%B7%E9%A2%98day5/"/>
    <url>/2024/11/16/LeetCode%E5%88%B7%E9%A2%98day5/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day5"><a href="#LeetCode刷题day5" class="headerlink" title="LeetCode刷题day5"></a>LeetCode刷题day5</h1><h1 id="58-区间和"><a href="#58-区间和" class="headerlink" title="58. 区间和"></a>58. 区间和</h1><blockquote><p>本题为代码随想录后续扩充题目，还没有视频讲解，顺便让大家练习一下ACM输入输出模式（笔试面试必备）</p></blockquote><p><a href="https://kamacoder.com/problempage.php?pid=1070">题目链接(opens new window)</a></p><p><a href="https://kamacoder.com/problempage.php?pid=1070">https://kamacoder.com/problempage.php?pid=1070</a></p><p>题目描述</p><p>给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。</p><p>输入描述</p><p>第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。</p><p>输出描述</p><p>输出每个指定区间内元素的总和。</p><p>输入示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">5<br>1<br>2<br>3<br>4<br>5<br>0 1<br>1 3<br></code></pre></td></tr></table></figure><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p><p>输出示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">3<br>9<br></code></pre></td></tr></table></figure><p>1<br>2</p><p>数据范围：</p><p>0 &lt; n &lt;&#x3D; 100000</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>一看，这不是简单开肝吗！每次都从i~j累加，超简单。提交呢，发现时间超限了。作者大大说，他故意的，没错。。。去看看他怎么想的——前缀和！！！累加相减就行。优雅，时间复杂度O(N)。</p><p>要注意的地方是：</p><ol><li><p><strong>输入直至文件结束</strong>，怎么处理？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(cin&gt;&gt;i&gt;&gt;j)<br></code></pre></td></tr></table></figure></li><li><p>而且，要习惯用vector，有什么好处呢，直接用数组不好吗？待我探究一番。在C++中，std::vector是标准模板库（STL）的一部分，提供了一个动态数组的功能。vector与数组的比较：</p><ul><li>动态大小 ：与固定大小的数组不同，vector的大小可以在运行时动态增长或缩减。</li><li>内存管理 ：vector自动处理其存储的分配和释放，无需程序员手动管理内存。</li><li>灵活性 ：vector提供了一系列成员函数，用于插入、删除和访问元素，这使得数据的处理更加灵活和方便。</li></ul></li><li><p>还要注意，scanf和printf比（cin,cout)高效。C++ 代码 面对大量数据 读取 输出操作，最好用scanf 和 printf，耗时会小很多：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b))<span class="hljs-comment">//更高效</span><br><span class="hljs-keyword">while</span>(cin&gt;&gt;i&gt;&gt;j)<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> p[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        cin&gt;&gt;a[i];<br><br>    &#125;<br>    p[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;<br>        p[i]=p[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>   <span class="hljs-comment">/*for(int i=0;i&lt;n;i++) &#123;</span><br><span class="hljs-comment">       cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">    cout&lt;&lt;endl;*/</span><br><br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;i&gt;&gt;j) &#123;<br><br>        cout&lt;&lt;p[j]-p[i]+a[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="44-开发商购买土地"><a href="#44-开发商购买土地" class="headerlink" title="44. 开发商购买土地"></a>44. 开发商购买土地</h1><blockquote><p>本题为代码随想录后续扩充题目，还没有视频讲解，顺便让大家练习一下ACM输入输出模式（笔试面试必备）</p></blockquote><p><a href="https://kamacoder.com/problempage.php?pid=1044">题目链接(opens new window)</a></p><p><a href="https://kamacoder.com/problempage.php?pid=1044">https://kamacoder.com/problempage.php?pid=1044</a></p><p>【题目描述】</p><p>在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。</p><p>现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。</p><p>然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。</p><p>为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。</p><p>注意：区块不可再分。</p><p>【输入描述】</p><p>第一行输入两个正整数，代表 n 和 m。</p><p>接下来的 n 行，每行输出 m 个正整数。</p><p>输出描述</p><p>请输出一个整数，代表两个子区域内土地总价值之间的最小差距。</p><p>【输入示例】</p><p>3 3 1 2 3 2 1 3 1 2 3</p><p>【输出示例】</p><p>0</p><p>【提示信息】</p><p>如果将区域按照如下方式划分：</p><p>1 2 | 3 2 1 | 3 1 2 | 3</p><p>两个子区域内土地总价值之间的最小差距可以达到 0。</p><p>【数据范围】：</p><ul><li>1 &lt;&#x3D; n, m &lt;&#x3D; 100；</li><li>n 和 m 不同时为 1。</li></ul><h2 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h2><p>枚举分割线，依次求两部分的和。但是可以用前缀和的思路，这里先统计行和，列和，再对它们用前缀和来解决。时间复杂度也是O(N^2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> a[n][m];<br>    <span class="hljs-type">int</span> row[n];<br>    <span class="hljs-type">int</span> col[m];<br>    <span class="hljs-comment">//输入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++) &#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//求前缀和</span><br>    <span class="hljs-type">int</span> qr[n];<br>    <span class="hljs-type">int</span> qc[m];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        row[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化</span><br>        qr[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++) &#123;<br>            row[i]+=a[i][j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>            qr[i]=row[i];<br>        <span class="hljs-keyword">else</span><br>            qr[i]=qr[i<span class="hljs-number">-1</span>]+row[i];<br><br>        <span class="hljs-comment">//cout &lt;&lt; row[i] &lt;&lt; &quot; &quot;;</span><br>    &#125;<br>    <span class="hljs-comment">//cout &lt;&lt; endl;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;<br>        col[i]=<span class="hljs-number">0</span>;<br>        qc[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>            col[i]+=a[j][i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>            qc[i]=col[i];<br>        <span class="hljs-keyword">else</span><br>            qc[i]=qc[i<span class="hljs-number">-1</span>]+col[i];<br>        <span class="hljs-comment">//cout &lt;&lt; col[i] &lt;&lt; &quot; &quot;;</span><br>    &#125;<br>    <span class="hljs-comment">//cout&lt;&lt;endl;</span><br>  <span class="hljs-comment">//for row</span><br>    <span class="hljs-comment">//cout&lt;&lt;&quot;******&quot;&lt;&lt;endl;</span><br><br>   <span class="hljs-comment">// cout&lt;&lt;&quot;qr&quot;&lt;&lt;endl;</span><br>   <span class="hljs-comment">/* for(int i=0;i&lt;n;i++) &#123;</span><br><span class="hljs-comment">        cout&lt;&lt;qr[i]&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    cout&lt;&lt;endl;</span><br><span class="hljs-comment">    cout&lt;&lt;&quot;******&quot;&lt;&lt;endl;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    cout&lt;&lt;&quot;qc&quot;&lt;&lt;endl;*/</span><br>   <span class="hljs-comment">/* for(int i=0;i&lt;m;i++) &#123;</span><br><span class="hljs-comment">        cout&lt;&lt;qc[i]&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    cout&lt;&lt;endl;*/</span><br><span class="hljs-comment">//枚举分割线</span><br>    <span class="hljs-type">int</span> minr=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-type">int</span> first=qr[i];<br>        <span class="hljs-type">int</span> second=qr[n<span class="hljs-number">-1</span>]-qr[i];<br>        minr=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(second-first),minr);<br>    &#125;<br>    <span class="hljs-type">int</span> minc=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;<br>        <span class="hljs-type">int</span> first=qc[i];<br>        <span class="hljs-type">int</span> second=qc[m<span class="hljs-number">-1</span>]-qc[i];<br>        minr=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(second-first),minr);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">min</span>(minc,minr)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，数组篇刷题结束，顺便夹杂了两道动态规划的题，因为这学期恰好有算法设计与分析课。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day4</title>
    <link href="/2024/11/15/LeetCode%E5%88%B7%E9%A2%98day4/"/>
    <url>/2024/11/15/LeetCode%E5%88%B7%E9%A2%98day4/</url>
    
    <content type="html"><![CDATA[<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>         <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获得尺寸是这样</span><br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-comment">// cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;endl;</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m*n)</span></span>;<span class="hljs-comment">//声明是这样</span><br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> b=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (k&lt;m*n) &#123;<br>        <span class="hljs-keyword">while</span>(j&lt;=r&amp;&amp;k&lt;m*n) &#123;<span class="hljs-comment">//最后退出边界时，卡了贼就，k&lt;m*n,不然会一直往下走</span><br>            res[k++]=matrix[i][j++];<br>        &#125;<br>        j--;<br>        i++;<br>        r--;<br>        <span class="hljs-keyword">while</span> (i&lt;=b&amp;&amp;k&lt;m*n) &#123;<br>            res[k++]=matrix[i++][j];<br>        &#125;<br>        i--;<br>        j--;<br>        b--;<br>        <span class="hljs-keyword">while</span> (j&gt;=l&amp;&amp;k&lt;m*n) &#123;<br>            res[k++]=matrix[i][j--];<br>        &#125;<br>        j++;<br>        i--;<br>        l++;<br>        <span class="hljs-keyword">while</span> (i&gt;t&amp;&amp;k&lt;m*n) &#123;<br>            res[k++]=matrix[i--][j];<br>        &#125;<br>        i++;<br>        j++;<br>        t++;<br>    &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="59-螺旋矩阵Ⅱ"><a href="#59-螺旋矩阵Ⅱ" class="headerlink" title="59.螺旋矩阵Ⅱ"></a>59.螺旋矩阵Ⅱ</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">//通过边界的缩小来控制螺旋填入数字</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">//int a[n][n];</span><br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//边界</span><br>        <span class="hljs-type">int</span> b=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k&lt;=n*n) &#123;<br>        <span class="hljs-keyword">while</span>(j&lt;=r&amp;&amp;k&lt;=n*n) &#123;<br>            a[i][j++]=k++;<br>        &#125;<br>        j--;<br>        i++;<br>        r--;<br>        <span class="hljs-keyword">while</span> (i&lt;=b&amp;&amp;k&lt;=n*n) &#123;<br>            a[i++][j]=k++;<br>        &#125;<br>        i--;<br>        j--;<br>        b--;<br>        <span class="hljs-keyword">while</span> (j&gt;=l&amp;&amp;k&lt;=n*n) &#123;<br>            a[i][j--]=k++;<br>        &#125;<br>        j++;<br>        i--;<br>        l++;<br>        <span class="hljs-keyword">while</span> (i&gt;t&amp;&amp;k&lt;=n*n) &#123;<span class="hljs-comment">//注意细节</span><br>            a[i--][j]=k++;<br>        &#125;<br>        i++;<br>        j++;<br>        t++;<br>    &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day3</title>
    <link href="/2024/11/14/LeetCode%E5%88%B7%E9%A2%98day3/"/>
    <url>/2024/11/14/LeetCode%E5%88%B7%E9%A2%98day3/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day3"><a href="#LeetCode刷题day3" class="headerlink" title="LeetCode刷题day3"></a>LeetCode刷题day3</h1><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p><p><strong>子数组</strong></p><p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：target = <span class="hljs-number">11</span>, nums = [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = INT_MAX, sublen = <span class="hljs-number">0</span>;<span class="hljs-comment">//正无穷 INT_MAX</span><br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<span class="hljs-comment">//处理永远都进不来的情况</span><br>                    flag = <span class="hljs-number">1</span>;<br>                sublen = j - i + <span class="hljs-number">1</span>;<br>                res = <span class="hljs-built_in">min</span>(res, sublen);<br>                sum -= nums[i++];<span class="hljs-comment">//起始窗口滑动</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<br>            res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a>904. 水果成篮</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：fruits </span>=<span class="hljs-string"> [1,2,1]</span><br><span class="hljs-string">输出：3</span><br><span class="hljs-string">解释：可以采摘全部 3 棵树。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[0,1,2,2]</span><br>输出：3<br>解释：可以采摘 <span class="hljs-comment">[1,2,2]</span> 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[0,1]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[1,2,3,2,2]</span><br>输出：4<br>解释：可以采摘 <span class="hljs-comment">[2,3,2,2]</span> 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[1,2]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：fruits = [<span class="hljs-number">3,3,3,1</span>,<span class="hljs-number">2,1,1,2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：可以采摘 [<span class="hljs-number">1,2,1,1</span>,<span class="hljs-number">2</span>] 这五棵树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= fruits.length &lt;= 105</code></li><li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-comment">//本题复杂度O(N),nice! 用滑动窗口的思想做的，上一题是209，长度最小的子数组</span><br>        <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<span class="hljs-comment">//用一道指针遍历</span><br>        <span class="hljs-type">int</span> type1 = fruits[<span class="hljs-number">0</span>], type2 = <span class="hljs-number">-2</span>;<br>        <span class="hljs-type">int</span> sub1 = <span class="hljs-number">0</span>, sub2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//分别表示第一种开始，第二种开始的位置</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">//最后结果，总是记录最好的结果</span><br>        <span class="hljs-keyword">if</span> (fruits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<span class="hljs-comment">//因为后续直接从1开始遍历，这里要考虑只有一个数据的情况</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (end = <span class="hljs-number">1</span>; end &lt; fruits.<span class="hljs-built_in">size</span>(); end++) &#123;<br>            <span class="hljs-keyword">if</span> (fruits[end] != type1 &amp;&amp; type2 == <span class="hljs-number">-2</span>) &#123;<span class="hljs-comment">//处理第一次碰到两种水果的情况</span><br>                type2 = fruits[end];<br>                sub2 = end;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fruits[end] != type1 &amp;&amp; fruits[end] != type2) &#123;<span class="hljs-comment">//碰到了第三种水果</span><br>                type1 = fruits[end - <span class="hljs-number">1</span>];<span class="hljs-comment">//上一种水果作为第一个篮子</span><br>                <span class="hljs-type">int</span> k = end - <span class="hljs-number">1</span>;<br>                sub1 = end;<br>                <span class="hljs-keyword">while</span> (fruits[k] == type1 &amp;&amp; k &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//去找到上一种水果是从哪里开始拿的</span><br>                    sub1--;<br>                    k--;<br>                &#125;<br>                type2 = fruits[end];<span class="hljs-comment">//现在碰到的新水果添加到第二种类型</span><br>                sub2 = end;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, end - sub1 + <span class="hljs-number">1</span>);<span class="hljs-comment">//每次只记录最好的结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day2</title>
    <link href="/2024/11/13/LeetCode%E5%88%B7%E9%A2%98day2/"/>
    <url>/2024/11/13/LeetCode%E5%88%B7%E9%A2%98day2/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day2"><a href="#LeetCode刷题day2" class="headerlink" title="LeetCode刷题day2"></a>LeetCode刷题day2</h1><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>已解答</p><p>简单</p><p>相关标签</p><p>相关企业</p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">4</span>,-<span class="hljs-number">1,0,3,10</span>]<br>输出：[<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br>解释：平方后，数组变为 [<span class="hljs-number">16,1,0,9</span>,<span class="hljs-number">100</span>]<br>排序后，数组变为 [<span class="hljs-number">0,1,9,16</span>,<span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [-<span class="hljs-number">7</span>,-<span class="hljs-number">3,2,3,11</span>]<br>输出：[<span class="hljs-number">4,9,9,49</span>,<span class="hljs-number">121</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//双指针，控制时间复杂度在O(N)</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//vector&lt;int&gt; ans[n];//have propblem 不能这样声明</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> pos=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=n<span class="hljs-number">-1</span>;i&lt;=j;)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])&#123;<br>                ans[pos--]=nums[i]*nums[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans[pos--]=nums[j]*nums[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>已解答</p><p>简单</p><p>相关标签</p><p>相关企业</p><p>提示</p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p><strong>用户评测：</strong></p><p>评测机将使用以下代码测试您的解决方案：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> nums = [...]; <span class="hljs-comment">// 输入数组</span><br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span> = ...; <span class="hljs-comment">// 要移除的值</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> expectedNums = [...]; <span class="hljs-comment">// 长度正确的预期答案。</span><br>                            <span class="hljs-comment">// 它以不等于 val 的值排序。</span><br><br><span class="hljs-built_in">int</span> k = removeElement(nums, <span class="hljs-keyword">val</span>); <span class="hljs-comment">// 调用你的实现</span><br><br><span class="hljs-keyword">assert</span> k<span class="hljs-operator"> == </span>expectedNums.length;<br>sort(nums, <span class="hljs-number">0</span>, k); <span class="hljs-comment">// 排序 nums 的前 k 个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; actualLength; i++) &#123;<br>    <span class="hljs-keyword">assert</span> nums[i]<span class="hljs-operator"> == </span>expectedNums[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], val = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span>, nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">_</span>,<span class="hljs-literal">_</span>]<br>解释：你的函数函数应该返回 k = <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。<br>你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,4,0</span>,<span class="hljs-number">3</span>,_,_,_]<br>解释：你的函数应该返回 k = <span class="hljs-number">5</span>，并且 nums 中的前五个元素为 <span class="hljs-number">0,0,1,3</span>,<span class="hljs-number">4</span>。<br>注意这五个元素可以任意顺序返回。<br>你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。<br></code></pre></td></tr></table></figure><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j;)&#123;<br>               <span class="hljs-keyword">if</span>(nums[i]==val)&#123;<br>                k++;<br>                nums[i]=nums[j<span class="hljs-number">-1</span>];<br>                j--;<br>                <br>            &#125;<br>            <span class="hljs-keyword">else</span> i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<span class="hljs-comment">//有点粗心，返回值这里，返回的k,搞了很久，无语</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mid = nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>;<span class="hljs-comment">//这样写，注意不用-1</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//int mid = (l + r) / 2;//先算lr,后m，这样会好点＜（＾－＾）＞</span><br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> mid;<br><br>            mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (l &gt; r)<span class="hljs-comment">//是可以相等的</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题day1</title>
    <link href="/2024/11/12/LeetCode%E5%88%B7%E9%A2%98day1/"/>
    <url>/2024/11/12/LeetCode%E5%88%B7%E9%A2%98day1/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题day1"><a href="#LeetCode刷题day1" class="headerlink" title="LeetCode刷题day1"></a>LeetCode刷题day1</h1><h2 id="LCR-095-最长公共子序列"><a href="#LCR-095-最长公共子序列" class="headerlink" title="LCR 095. 最长公共子序列"></a>LCR 095. 最长公共子序列</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;def&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：两个字符串没有公共子序列，返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>这是一道动态规划题，LCS，它不要求连续，只要求顺序，这有点像最长字串问题，但是，是否感觉更有意思？</p><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day1/image-20241112163520255.png" alt="image-20241112163520255"></p><p><code>s1 = &quot;abcde&quot;, s2 = &quot;ace&quot; </code></p><h4 id="1-定义：D-i-j-定义为s1前i个字符-与-s2前j个字符的LCS。"><a href="#1-定义：D-i-j-定义为s1前i个字符-与-s2前j个字符的LCS。" class="headerlink" title="1. 定义：D[i][j]定义为s1前i个字符 与 s2前j个字符的LCS。"></a>1. 定义：<code>D[i][j]</code>定义为s1前i个字符 与 s2前j个字符的LCS。</h4><h4 id="2-分解：从最终状态往前推演。"><a href="#2-分解：从最终状态往前推演。" class="headerlink" title="2. 分解：从最终状态往前推演。"></a>2. 分解：从最终状态往前推演。</h4><p>①末尾能匹配上：<code>D[i][j] = 1 +D[i-1][j-1] </code></p><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day1/image-20241112170917096.png" alt="image-20241112170917096"></p><p>②末尾不能匹配上： 丢掉<code>s1</code>末尾：<code>D[i][j] = D[i-1][j] </code></p><pre><code class="hljs">                丢掉`s2`末尾：`D[i][j] = D[i][j-1] `</code></pre><p>谁效果好留下谁。即：<code>D[i][j] = max( D[i][j-1], D[i][j-1]) </code></p><h4 id="3-子问题"><a href="#3-子问题" class="headerlink" title="3.子问题"></a>3.子问题</h4><ul><li>D<sub>00</sub> &#x3D; 0</li><li>D<sub>0j</sub> &#x3D; 0</li><li>D<sub>i0</sub> &#x3D;0</li></ul><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day1/image-20241112173022008.png" alt="image-20241112173022008"></p><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day1/image-20241112175727148.png" alt="image-20241112175727148"></p><h3 id="上代码："><a href="#上代码：" class="headerlink" title="上代码："></a>上代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//注意i,j对应问题</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> d[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000</span>;j++)<br>            d[i][j]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> LCS=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s<span class="hljs-number">1.l</span>ength();i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=s<span class="hljs-number">2.l</span>ength();j++) &#123;<br>            <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>]==s2[j<span class="hljs-number">-1</span>]) &#123;<span class="hljs-comment">//i-1，j-1</span><br>                d[i][j]=d[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<span class="hljs-number">+1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                d[i][j]= <span class="hljs-built_in">max</span>(d[i<span class="hljs-number">-1</span>][j],d[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(LCS&lt;d[i][j]) &#123;<br>                LCS=d[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> LCS;<span class="hljs-comment">//找到最大值，其实右下角，一定是最大值</span><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：数组可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>这就是个01背包问题。</p><h4 id="什么是01背包问题？"><a href="#什么是01背包问题？" class="headerlink" title="什么是01背包问题？"></a>什么是01背包问题？</h4><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day1/image-20241112175443947.png" alt="image-20241112175443947"><br><img src="/img/LeetCode%E5%88%B7%E9%A2%98day1/image.png" alt="image-20241112175705064"></p><p><img src="/img/LeetCode%E5%88%B7%E9%A2%98day1/image-20241112175705064.png" alt="image-20241112175705064"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题就是把数组一分为二，且是均分。因此，如果数组累加和为奇数，肯定不行。注意题目的范围，注意调整。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>            c+=nums[i];<br>        <span class="hljs-keyword">if</span>(c%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<span class="hljs-comment">//先排除一部分</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;    <br>        c/=<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> m=c<span class="hljs-number">+3</span>;<br>        <span class="hljs-type">int</span> d[<span class="hljs-number">201</span>][m];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">201</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<span class="hljs-comment">//注意界限，直接开大数组，容易超时</span><br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>)<br>            d[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;=c ; j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&gt;j)&#123;<span class="hljs-comment">//can&#x27;t，直接放不进去</span><br>                    d[i][j]=d[i<span class="hljs-number">-1</span>][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    d[i][j]=<span class="hljs-built_in">max</span>(nums[i<span class="hljs-number">-1</span>]+d[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]],d[i<span class="hljs-number">-1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)<br>            <span class="hljs-keyword">if</span>(d[i][j]==c)<span class="hljs-comment">//d[i][j]装的就是数字和，也就是value价值，就是c；通俗讲，d[i][j]求出的就是能拿进背包的数字，他们的价值=1/2全部，剩下的自然也是1/2全部</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown-DEMO</title>
    <link href="/2024/11/12/markdown-DEMO/"/>
    <url>/2024/11/12/markdown-DEMO/</url>
    
    <content type="html"><![CDATA[<p>记笔记调格式，忘了的话，来看看demo<br><a href="https://markdown-it.github.io/">https://markdown-it.github.io/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Google学术搜索镜像网站</title>
    <link href="/2024/11/06/Google%E5%AD%A6%E6%9C%AF%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/"/>
    <url>/2024/11/06/Google%E5%AD%A6%E6%9C%AF%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>服务器ip被谷歌学术禁了，无法访问，原因不清楚；找个镜像网站查查论文吧，汗流浃背了，科研路上一路打怪。<br><a href="https://ac.scmor.com/">https://ac.scmor.com/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Github+hexo搭建博客详细记录</title>
    <link href="/2024/11/05/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/11/05/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>全部搭建过程参考文章：</strong><a href="https://blog.csdn.net/yaorongke/article/details/119089190"><strong>https://blog.csdn.net/yaorongke/article/details/119089190</strong></a></p><p>SSH设置：<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md">https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md</a></p><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h3><h4 id="1-注册GitHub账号"><a href="#1-注册GitHub账号" class="headerlink" title="1.   注册GitHub账号"></a><strong>1.</strong>   <strong>注册GitHub账号</strong></h4><p>首先需要有一个GitHub账号，没有的话到先到GitHub官网注册（<a href="https://github.com/%EF%BC%89%E3%80%82">https://github.com/）。</a></p><p>注册可参考GitHub申请账号教程<a href="https://blog.csdn.net/yaorongke/article/details/119086305">https://blog.csdn.net/yaorongke/article/details/119086305</a></p><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a><strong>2.</strong> <strong>安装Git</strong></h4><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。参考 Git安装(网址：<a href="https://blog.csdn.net/yaorongke/article/details/119085413?fromshare=blogdetail&sharetype=blogdetail&sharerId=119085413&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">https://blog.csdn.net/yaorongke/article/details/119085413?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=119085413&amp;sharerefer=PC&amp;sharesource=weixin_62431476&amp;sharefrom=from_link</a>)</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image1.png" alt=" "></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image2.png" alt=" "></p><h4 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3. 安装NodeJS"></a><strong>3.</strong> <strong>安装NodeJS</strong></h4><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。可参考NodeJS安装及配置(Windows)——</p><p><a href="https://blog.csdn.net/yaorongke/article/details/119084295?fromshare=blogdetail&sharetype=blogdetail&sharerId=119084295&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">https://blog.csdn.net/yaorongke/article/details/119084295?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=119084295&amp;sharerefer=PC&amp;sharesource=weixin_62431476&amp;sharefrom=from_link</a></p><p>我的安装具体步骤：</p><h5 id="（1）下载安装包"><a href="#（1）下载安装包" class="headerlink" title="（1）下载安装包"></a><strong>（1）下载安装包</strong></h5><p>NodeJS官网下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image3.png" alt=" "><br>下载安装包后双击安装包开始安装，一路点击Next即可，安装完成后，msi格式的安装包会自动添加环境变量。</p><p>安装finish后打开cmd，执行命令node -v查看node版本</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image4.png" alt=" "></p><p>在安装node的同时也安装了npm，执行 npm -v 查看npm版本</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image5.png" alt=" "></p><p>成功查看后就安装完成可以正常使用了，参考文章内还有讲解修改全局包配置，但我不需要这个所以省略后半部分，有需要可访问步骤3的网址。</p><h3 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a><strong>二、创建仓库</strong></h3><p><strong>1.</strong> 在GitHub上<strong>创建一个新的代码仓库</strong>用于保存我们的网页。点击<strong>Your repositories</strong>，进入仓库页面。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image6.png" alt=" "><br><strong>2.</strong> <strong>点击New</strong>按钮，进入仓库创建页面。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/7.png" alt=" "></p><p><strong>3.</strong> <strong>填写仓库名</strong>（必须与用户名一致），格式必须为&lt;用户名&gt;.github.io，然后点击Create repository。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/8.png" alt=" "></p><p> <strong>4.</strong> <strong>点击creating a new file</strong>创建一个新文件，作为我们网站的主页。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/9.png" alt=" "><br><strong>5.</strong> <strong>新文件的名字必须为index.html</strong>，内容先随便写一个简单的，填写之后点击Commit new file提交。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/10.png" alt=" "><br>填写内容示例如下：</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/11.png" alt=" "><br><strong>6.</strong> 在仓库页面，从上方导航栏<strong>进入“Settings”-“Pages”</strong>,找到主页的地址，示例为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/12.png" alt=" "><br><strong>7.</strong> 接下来直接访问查询到的主页地址<a href="https://yaorongke.github.io/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%AE%80%E9%99%8B%E7%9A%84%E7%BD%91%E9%A1%B5%EF%BC%9A">https://yaorongke.github.io/，可以看到一个比较简陋的网页：</a></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/13.png" alt=" "></p><h3 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a><strong>三、安装Hexo</strong></h3><p>Hexo 是一个基于NodeJS的静态博客网站生成器，使用Hexo不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。Hexo官网<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.   安装hexo"></a><strong>1.</strong>   <strong>安装hexo</strong></h4><p>注意，<strong>第一个坑来了！</strong>——自行创建一个WorkSpace-blog目录，在该目录下安装hexo，安装hexo命令以官网为准npm install hexo-cli -g，参考文章内的命令不知道为啥不可用，归结为坑（bushi）</p><p><code>npm install hexo-cli -g</code></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/14.png" alt=" "></p><ol start="2"><li>安装成功后查看版本</li></ol><p><code>hexo -v</code></p><ol start="3"><li>创建一个项目 hexo-blog 并初始化，</li></ol><p><code>hexo init blog</code></p><p><code>cd blog</code></p><p><code>npm install</code></p><ol start="4"><li>本地启动</li></ol><p><code>hexo g</code></p><p><code>hexo server</code></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/15.png" alt=" "><br>这里有个踩过的坑：</p><p>启动失败了，原因是<strong>4000端口被占用</strong>，使用hexo s -p 8080命令<strong>更换端口</strong>.( 启动时需要在hexo-blog目录下)以自己的目录为准。</p><p>​                 更换为8080端口即可成功启动                </p><p>​                 启动失败，4000端口被占用                </p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/16.png" alt=" "></p><h3 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a><strong>四、更换主题</strong></h3><h4 id="1-下载Fluid主题"><a href="#1-下载Fluid主题" class="headerlink" title="1. 下载Fluid主题"></a><strong>1.</strong> 下载Fluid主题</h4><p>  进入<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a>安装主题，<strong>点击“最新 release 版本”</strong>下滑找到<strong>“Assets”</strong>部分。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/17.png" alt=" "></p><p>下载压缩包并解压到 “hexo-blog” – “themes” 目录，并将解压出的文件夹<strong>重命名为 fluid</strong><br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/18.png" alt=" "></p><h4 id="2-指定主题"><a href="#2-指定主题" class="headerlink" title="2.   指定主题"></a><strong>2.</strong>   <strong>指定主题</strong></h4><p>如下修改hexo-blog目录中的 _config.yml文件的them和language（用vscode软件打开hexo-blog目录会非常好修改，后续需要执行的命令行也可以直接在vscode终端执行）：</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/19.png" alt=" "></p><p>我的vscode修改界面：<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/20.png" alt=" "></p><ol start="3"><li><h4 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a><strong>创建「关于页」</strong></h4></li></ol><p>首次使用主题的「关于页」需要<strong>手动创建</strong>：</p><p><code>hexo new page about</code></p><p>创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，<strong>添加 layout 属性</strong>。</p><p>修改后的文件示例如下：<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/21.png" alt=" "></p><h3 id="五、发布到GitHub-Pages"><a href="#五、发布到GitHub-Pages" class="headerlink" title="五、发布到GitHub Pages"></a><strong>五、发布到GitHub Pages</strong></h3><h4 id="1-安装hexo-deployer-git"><a href="#1-安装hexo-deployer-git" class="headerlink" title="1.   安装hexo-deployer-git"></a><strong>1.</strong>   <strong>安装hexo-deployer-git</strong></h4><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/22.png" alt=" "></p><ol start="2"><li>修改 hexo-blog目录下的config.yml，配置 GitHub 相关信息</li></ol><p>坑！</p><p>配置.yml文件时，<strong>注意空格！！！</strong>否则报错</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/23.png" alt=" "></p><p>接下来两个推送方式：</p><p>（1）参考文章内（如下）的配置方式部署不知道为什么一直没成功，放弃了。。。。。<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/24.png" alt=" "></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/25.png" alt=" "><br>这个问题暂时没解决，推送换了ssh连接</p><p>（2）换成ssh推送继续往下肝，这里开始参考开头提到的第二篇文章：[**<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md**]">https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md**]</a>(<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo">https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo</a> %2B github搭建个人博客教程.md)</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/26.png" alt=" "><br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/27.png" alt=" "><br>以上步骤非常清晰，浅提几个点：</p><p>l  一开始没有.ssh目录，执行了命令ssh-keygen -t rsa -C “my email”命令，这里我是在c:&#x2F;用户&#x2F;username&#x2F;目录下执行的，生成完成后用记事本打开id_ras.pub文件，然后Ctrl-A复制所有内容。</p><p>l  接下来的github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。对应图片放这里：<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/28.png" alt=" "></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/29.png" alt=" "></p><p>l  最后的url配置的就是步骤二-7中的主页地址</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/30.png" alt=" "></p><p>l  repo的内容在仓库页面-code-SSH可以直接复制<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/31.png" alt=" "></p><p>l  全部修改完配置保存后执行hexo g -d，部署完成后就可以打开主页：</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/32.png" alt=" "></p><hr><p>再附上之前我自己写的注意事项，记录点东西确实还是能帮上忙哦！</p><ol><li>Node下载，注意看是否直接下载安装程序，压缩包还不会使用。</li><li>在npm运行，就是Node，下载好了cmd到folder，执行npm命令就行。</li><li>注意.ignore文件，否则上传一大堆。</li><li>github分支很重要，默认执行分支main，这就会出现部署到master分支，本地能成功执行hexo，但是github访问不到，去setting切换分支即可。<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image.png" alt=" "></li><li>github pages没有实时更改内容是很正常的，发布前先<code>hexo s -p 8080</code>，本地执行没问题，先使用 <code>hexo clean</code> 清除本地缓存，然后<code>hexo g -d</code>提交。</li><li>新建文章很简单，<code>hexo new name</code> 即可。</li><li>发布照片时，要把生成的照片文件夹放到source下的img静态资源文件夹，养成良好习惯，放在post里面无法访问。</li></ol><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/37.png" alt=" "></p><ol start="8"><li>稍微有一些地方没设置成功，都无法访问。今天的情况是，都部署成功了，githubPages能看得到第一篇文章，但是后续发布的文章一直没法看到，github代码也显示push成功。出了什么问题呢？确保 GitHub Pages 设置正确：</li></ol><p>在仓库的 Settings &gt; Pages 中，设置发布来源为 GitHub Actions 自动生成的文件。直接上图，真的shit，好在终于成功啦！<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/38.png" alt=" "></p><hr><p>以上是我帮ie家族一员Winnie配置时遇到的问题，尽管9月份我已经配置过了，苦于没有留下详细的说明文档，导致这次踩坑很多还是要不停搜索。于是我们两人决定写一份说明文档，当然，这份保姆级别教程要感谢Winnie~  Jessie主要是技术支持哈哈哈。Winnie会来看我的主页吗，不知道，祝她找工作顺利！可爱善良的女孩呀，幸福会来敲门的！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>提交新文章注意事项</title>
    <link href="/2024/11/05/%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2024/11/05/%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>突然考虑到，万一我本地源码炸了怎么办？那就直接备份一手吧，有备无患。</p><h2 id="开局报错："><a href="#开局报错：" class="headerlink" title="开局报错："></a>开局报错：</h2><p><img src="/img/%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image.png" alt="图片引用方法二"></p><h2 id="先去解决一下："><a href="#先去解决一下：" class="headerlink" title="先去解决一下："></a>先去解决一下：</h2><p>在本仓库，新建了一个分支blog，里面存放源码，操作步骤如下：<br>要将代码推送到 Git 仓库，以下是常规的步骤：</p><h3 id="1-确认本地仓库已初始化"><a href="#1-确认本地仓库已初始化" class="headerlink" title="1. 确认本地仓库已初始化"></a>1. 确认本地仓库已初始化</h3><p>确保你的项目已经初始化为一个 Git 仓库，并且目录中有 <code>.git</code> 文件夹。如果还没有初始化，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><h3 id="2-添加远程仓库地址"><a href="#2-添加远程仓库地址" class="headerlink" title="2. 添加远程仓库地址"></a>2. 添加远程仓库地址</h3><p>如果还没有设置远程仓库，需要将远程仓库地址添加到本地仓库。你可以用以下命令将仓库的 <code>origin</code> 设置为远程仓库地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;仓库地址&gt;<br></code></pre></td></tr></table></figure><p>例如，使用 GitHub 上的仓库地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://github.com/your-username/your-repo.git<br></code></pre></td></tr></table></figure><h3 id="3-切换到新分支"><a href="#3-切换到新分支" class="headerlink" title="3. 切换到新分支"></a>3. 切换到新分支</h3><p>创建新分支后，你可以使用 git checkout &lt;分支名&gt; 切换到该分支<br>查看分支<br>git branch</p><h3 id="4-添加文件并提交更改"><a href="#4-添加文件并提交更改" class="headerlink" title="4. 添加文件并提交更改"></a>4. 添加文件并提交更改</h3><p>将文件添加到暂存区并提交更改： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;提交信息&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-推送到远程仓库"><a href="#4-推送到远程仓库" class="headerlink" title="4. 推送到远程仓库"></a>4. 推送到远程仓库</h3><p>将代码推送到远程仓库的指定分支（通常是 <code>main</code> 或 <code>master</code> 分支）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin main<br></code></pre></td></tr></table></figure><blockquote><p><code>-u</code> 选项会将本地分支与远程分支关联，以后推送时只需运行 <code>git push</code>。</p></blockquote><h3 id="5-后续推送"><a href="#5-后续推送" class="headerlink" title="5. 后续推送"></a>5. 后续推送</h3><p>之后的更改只需执行以下命令即可推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;更新信息&quot;</span><br>git push<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果远程仓库有更新的代码，在推送之前先拉取最新代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main<br></code></pre></td></tr></table></figure><p>推送完成后，你可以在远程仓库中查看提交的代码。<br><img src="/img/%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image1.png" alt="alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-169.多数元素</title>
    <link href="/2024/11/05/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2024/11/05/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何科学上网</title>
    <link href="/2024/11/04/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <url>/2024/11/04/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>一、下载代理</p><ol><li>v2rayN or clash<br><img src="/img/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image.png" alt="alt text"><br>v2rayN 官网：<a href="https://getv2rayn.com/">https://getv2rayn.com/</a><br>下载地址：<a href="https://dl.p6p.net/v2rayN/">https://dl.p6p.net/v2rayN/</a><br><img src="/img/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image1.png" alt="alt text"><br>二、购买网络<br>性价比机场：<br><a href="https://性价比机场.com/#/knowledge">https://xn--6nq44r2uh9rhj7f.com/#/knowledge</a><br>注册邮箱（国内qq邮箱可用），登录购买后follow教程即可<br><img src="/img/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image2.png" alt="alt text"><br>三、安装教程配置 </li><li>按照网页教程配置 </li><li>v2rayN无法连接注意要设置默认跳过证书验证！<br><img src="/img/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image3.png" alt="alt text"></li></ol><p>升级版：自己搭建服务器，还没学哈哈</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>主定理的一个疑问</title>
    <link href="/2024/11/04/%E4%B8%BB%E5%AE%9A%E7%90%86%E7%9A%84%E4%B8%80%E4%B8%AA%E7%96%91%E9%97%AE/"/>
    <url>/2024/11/04/%E4%B8%BB%E5%AE%9A%E7%90%86%E7%9A%84%E4%B8%80%E4%B8%AA%E7%96%91%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/%E4%B8%BB%E5%AE%9A%E7%90%86%E7%9A%84%E4%B8%80%E4%B8%AA%E7%96%91%E9%97%AE/image.png" alt="图片引用方法二"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-435.无重叠区间</title>
    <link href="/2024/11/04/LeetCode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <url>/2024/11/04/LeetCode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-321.拼接最大数</title>
    <link href="/2024/11/04/LeetCode-321-%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <url>/2024/11/04/LeetCode-321-%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-53.最大子数组和</title>
    <link href="/2024/11/04/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2024/11/04/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>latex使用记录</title>
    <link href="/2024/10/31/latex%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/10/31/latex%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ol><li>参考文献<br>在tex同级目录添加.bib文件，其中填写引用格式的bibtex<br>1.1 在导言部分加<br>\usepackage{cite}  &#x2F;&#x2F;引用要加的包<br>\usepackage[hidelinks]{hyperref} &#x2F;&#x2F;去掉引用效果绿框和链接跳转<br>\usepackage[numbers,sort&amp;compress]{natbib}&#x2F;&#x2F;多个文献引用</li></ol><p>多文献引用格式:[1,2].   \cite{label1,label2}</p><p>多文献引用格式:[1,2][1-3]只有是三片文献以上才是连字符.  \usepackage[numbers,sort&amp;compress]{natbib}我所知道的是这是一种压缩的格式.</p><p>1.2 在参考文献出现的位置<br>\bibliographystyle{unsrt} &#x2F;&#x2F;按出现顺序编号参考文献<br>\bibliography{ref}&#x2F;&#x2F;导入刚才的bib文件</p><ol start="2"><li>图片跨栏居中<br>方法：使用 figure* 环境<br>在双栏文档中，将 figure 环境替换为 figure*，并将浮动参数设为 [t] 或 [b]，以控制图片出现在页面顶部或底部。</li></ol><p>\begin{figure*}[t] % 使用 figure* 环境，并设置 [t] 或 [b] 控制位置<br>    \centering<br>    \includegraphics[width&#x3D;\textwidth]{your-image.png} % 设置图片宽度为整页宽度<br>    \caption{Your Caption}<br>    \label{fig:your-label}<br>\end{figure*}</p><ol start="3"><li>图片索引居中<br>\usepackage[caption&#x3D;true,font&#x3D;normalsize,labelfont&#x3D;sf,textfont&#x3D;sf]{subfig}<br>模板默认是false<br>caption&#x3D;true改成true就行了</li></ol><p>Tip:有时会出现编译不成功的问题，只要在空白的地方随便打打即可重新编译成功；照片的位置好像不能指定；照片可以在label重新命名。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据集自动标注</title>
    <link href="/2024/10/24/%E6%95%B0%E6%8D%AE%E9%9B%86%E8%87%AA%E5%8A%A8%E6%A0%87%E6%B3%A8/"/>
    <url>/2024/10/24/%E6%95%B0%E6%8D%AE%E9%9B%86%E8%87%AA%E5%8A%A8%E6%A0%87%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<p>任务1：Anaconda配置</p><ol><li><p>Anaconda下载，选择适合自己操作系统的版本。清华镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p></li><li><p>安装Anaconda，并确保在安装过程中将Anaconda添加到系统环境变量中</p></li><li><p>验证Anaconda是否安装成功，在终端（或Anaconda Prompt）中运行以下命令并记录输出，输出应有版本号：<br> conda –version</p></li></ol><p>任务2：X-Anylabeling自动标注软件安装<br>参考博客<a href="https://blog.csdn.net/2303_80018785/article/details/139429062">https://blog.csdn.net/2303_80018785/article/details/139429062</a><br>注意，后续在命令行中，下载包时，不要开代理。</p><p>使用方法：</p><ol><li>打开 Anaconda prompt,电脑搜索即可</li><li>输入<br>conda activate label<br>cd C:\X-AnyLabeling-main     （改成你所用的地址）<br>python anylabeling&#x2F;app.py</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>快捷生成方法</title>
    <link href="/2024/09/18/%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/"/>
    <url>/2024/09/18/%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前端学习时Coding快捷方法"><a href="#前端学习时Coding快捷方法" class="headerlink" title="前端学习时Coding快捷方法"></a>前端学习时Coding快捷方法</h1><h4 id="快速生成HTML结构语法"><a href="#快速生成HTML结构语法" class="headerlink" title="快速生成HTML结构语法"></a>快速生成HTML结构语法</h4><ol><li>生成标签 直接输入标签名 按tab键即可 比如 div 然后tab键 ，就可以生成<div></div></li><li>如果想要生成多个相同标签 加上<em>就可以了比如 div</em>3 就可以快速生成3个div2.</li><li>如果有父子级关系的标签，可以用&gt;比如 u&gt;li就可以了</li><li>如果有兄弟关系的标签，用 + 就可以了 比如 div+p4</li><li>如果生成带有类名或者id名字的，直接写demo 或者 #two tab 键就可以了</li><li>如果生成的div类名是有顺序的，可以用自增符号 $</li><li>如果想要在生成的标签内部写内容可以用{}表示</li></ol><h4 id="CSS-基本采取简写形式即可"><a href="#CSS-基本采取简写形式即可" class="headerlink" title="CSS 基本采取简写形式即可"></a>CSS 基本采取简写形式即可</h4><ol><li>比如 w200 按tab 可以生成 width: 200px;</li><li>比如lh26 按tab 可以生成 line-height: 26px;</li></ol><h4 id="VS"><a href="#VS" class="headerlink" title="VS"></a>VS</h4><ol><li><p>vs保存自动格式化：左下角管理，设置，用户 文本编辑器 格式化</p></li><li><p>shift+alt+上下键快速复制粘贴一行代码</p></li></ol><h4 id="链接伪类选择器注意事项"><a href="#链接伪类选择器注意事项" class="headerlink" title="链接伪类选择器注意事项"></a>链接伪类选择器注意事项</h4><ol><li>为了确保生效，请按LVHA的循顺序声明:link-:visited-:hover-:active。</li><li>记忆法 :love hate 或者 Iv 包包 hao</li><li>因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。<br><img src="/img/%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/test.png" alt="链接器总结"></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome调试</title>
    <link href="/2024/09/18/Chrome%E8%B0%83%E8%AF%95/"/>
    <url>/2024/09/18/Chrome%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="F12打开Chrome调试界面"><a href="#F12打开Chrome调试界面" class="headerlink" title="F12打开Chrome调试界面"></a>F12打开Chrome调试界面</h2><ol><li>Ctrl+滚轮，可以放大开发者工具代码大小。</li><li>左边是 HTML元素结构，右边是 CSS 样式。</li><li>右边 CSS 样式可以改动数值(左右箭头或者直接输入)和查看颜色，</li><li>Ctrl +0 复原浏览器大小。</li><li>如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误如果有样式，但是样式前面有黄色叹号提示，则是样式属性书写错误。</li></ol><p><img src="/img/Chrome%E8%B0%83%E8%AF%95/test.png" alt="Chrome示例"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最近的打算</title>
    <link href="/2024/09/12/%E6%9C%80%E8%BF%91%E7%9A%84%E6%89%93%E7%AE%97/"/>
    <url>/2024/09/12/%E6%9C%80%E8%BF%91%E7%9A%84%E6%89%93%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Jessie最近在干啥？"><a href="#Jessie最近在干啥？" class="headerlink" title="Jessie最近在干啥？"></a>Jessie最近在干啥？</h2><p>  刚开学不久，花了两天的时间搭建好了自己的博客hexo+github，这篇文章才算是真正意义上的第一篇记录。搭建这个东西，真正是从无到有，搭建的过程学到了很多知识。下载VScode, Node.js, Git。学会使用git命令，真正自己搭了一个github仓库。有几个坑：</p><ol><li>Node下载，注意看是否直接下载安装程序，压缩包还不会使用。</li><li>在npm运行，就是Node，下载好了cmd到folder，执行npm命令就行。</li><li>注意.ignore文件，否则上传一大堆。</li><li>github分支很重要，默认执行分支main，这就会出现部署到master分支，本地能成功执行hexo，但是github访问不到，去setting切换分支即可。</li><li>github pages没有实时更改内容是很正常的，发布前先<code>hexo s -p 8080</code>，本地执行没问题，先使用 <code>hexo clean</code> 清除本地缓存，然后<code>hexo g -d</code>提交。</li><li>新建文章很简单，<code>hexo new name</code> 即可。</li><li>发布照片时，要把生成的照片文件夹放到source下的img静态资源文件夹，养成良好习惯，放在post里面无法访问。</li></ol><p>  有空再去探索如何美化博客吧，本来添加了访问记录，哈哈，不知为何没成功，最近没啥时间干这事了。接下来我打算每天学英语，尚雯婕老师推荐的训练方法！然后就是学习小程序开发和Vue。加油！今天看到B站评论说，互联网行情不好，有人回复说：客观事实改变不了，那就改变自己，努力学习，顺应时代变化，接受变化，努力赶上。加油啊，Jessie！</p><p>附上参考文章链接：这个实测成功，<a href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190</a><br>这个讲了SSH，我用的就是SSH，<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md">https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/09/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/09/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章<br>这是一篇测试文章</p><p><img src="/img/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/10/hello-world/"/>
    <url>/2024/09/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
